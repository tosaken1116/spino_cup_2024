package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func main() {
	opts := &protogen.Options{}
	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if strings.Contains(*f.Proto.Name, "resource") {

				continue

			}
			if strings.Contains(*f.Proto.Name, "rpc") {
				continue
			}
			if !strings.Contains(*f.Proto.Name, "rpc") && !strings.Contains(*f.Proto.Name, "resource") {

				generateMockApiClient(gen, gen.Files)
			}
		}
		return nil
	})
}

// import パスの生成
func generateImportPath(file *protogen.File, message *protogen.Message) string {
	// 他の proto ファイルに含まれる message 型の場合の正しいパスを生成
	sourceFile := message.Location.SourceFile
	packageName := strings.Replace(strings.Split(sourceFile, "/")[strings.Count(sourceFile, "/")], ".proto", "", -1)
	return fmt.Sprintf("../../domain/%s/model", strings.ToLower(packageName))
}

// インポートする型名を抽出
func getImportedTypes(usedTypes map[string]bool) string {
	types := ""
	for t := range usedTypes {
		types += t + ", "
	}
	return strings.TrimRight(types, ", ")
}

// Goの型をTypeScriptの型に変換する関数
func goToTSType(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "int32", "int64", "uint32", "uint64":
		return "number"
	case "bool":
		return "boolean"
	default:
		return "any"
	}
}

func generateMockApiClient(gen *protogen.Plugin, files []*protogen.File) {
	// "apiclient/index.ts" にファイルを生成
	outputPath := filepath.Join("index.ts")
	if _, err := os.Stat(outputPath); err == nil {
		// ファイルが既に存在する場合、生成をスキップ
		return
	}
	g := gen.NewGeneratedFile(outputPath, "")

	// import 文を先に生成
	g.P("// Code generated by protoc-gen-ts. DO NOT EDIT.")
	g.P("import { http, HttpResponse } from 'msw'")
	g.P("import { getBaseUrl } from \"../../libs/baseUrl\";")
	for _, file := range files {
		packageName := strings.ToLower(string(*file.Proto.Package))
		if !strings.HasPrefix(file.GoImportPath.String(), "\"./\"") {
			continue
		}
		if strings.Contains(packageName, "rpc") || strings.Contains(packageName, "resource") {
			continue // rpc や resource を含むパッケージをスキップ
		}
		packageName = strings.Replace(packageName, "api.", "", -1)
		g.P(fmt.Sprintf("import type * as %sSchema from '../apiclient/domain/%s/schema';", ToUpperCamelCase(packageName), packageName))
	}
	g.P("")

	// apiClient 関数の生成
	g.P("export const apiMockClientBase = (baseUrl: string) => ({")
	for _, file := range files {
		if !strings.HasPrefix(file.GoImportPath.String(), "\"./\"") {
			continue
		}
		packageName := strings.ToLower(string(*file.Proto.Package))
		if strings.Contains(packageName, "rpc") || strings.Contains(packageName, "resource") {
			continue // rpc や resource を含むパッケージをスキップ
		}
		packageName = strings.Replace(packageName, "api.", "", -1)
		g.P(fmt.Sprintf("  %s: {", packageName))
		for _, service := range file.Services {
			for _, method := range service.Methods {
				// HTTP メソッドと URL パスを取得
				httpRule := getHttpRule(method)
				httpMethod := getHttpMethod(httpRule)
				urlPath := applyPathParamsToURL(getUrlPath(httpRule))

				// メソッド名やリクエスト/レスポンス型の生成
				// reqType := fmt.Sprintf("%sSchema.%s", ToUpperCamelCase(packageName), method.Input.GoIdent.GoName)
				respType := fmt.Sprintf("%sSchema.%s", ToUpperCamelCase(packageName), method.Output.GoIdent.GoName)
				methodName := strings.ToLower(string(method.GoName[0])) + method.GoName[1:]

				// 各APIメソッドの生成
				g.P(fmt.Sprintf("		%s: (data: %s) =>", methodName, respType))
				g.P(fmt.Sprintf("			http.%s(`${baseUrl}%s`, () => {", httpMethod, urlPath))
				g.P("				return HttpResponse.json(data)")
				g.P("			}),")
			}
		}
		g.P("  },")
	}
	g.P("});")
	g.P("export const apiMockClient = apiMockClientBase(getBaseUrl())")
}

// HTTP ルールを取得するための関数
func getHttpRule(method *protogen.Method) *annotations.HttpRule {
	if proto.HasExtension(method.Desc.Options(), annotations.E_Http) {
		ext := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
		if httpRule, ok := ext.(*annotations.HttpRule); ok {
			return httpRule
		}
	}
	return nil
}

// HTTP メソッドを取得するための関数
func getHttpMethod(httpRule *annotations.HttpRule) string {
	if httpRule == nil {
		return "POST"
	}
	switch httpRule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return "get"
	case *annotations.HttpRule_Post:
		return "post"
	case *annotations.HttpRule_Put:
		return "put"
	case *annotations.HttpRule_Delete:
		return "delete"
	default:
		return "post"
	}
}

// URL パスを取得するための関数
func getUrlPath(httpRule *annotations.HttpRule) string {
	if httpRule == nil {
		return "/defaultPath"
	}
	switch pattern := httpRule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return pattern.Get
	case *annotations.HttpRule_Post:
		return pattern.Post
	case *annotations.HttpRule_Put:
		return pattern.Put
	case *annotations.HttpRule_Delete:
		return pattern.Delete
	default:
		return "/defaultPath"
	}
}

func applyPathParamsToURL(path string) string {
	if !strings.Contains(path, "{") {
		return path
	}

	properties := strings.Split(path, "/")
	for i, prop := range properties {
		if strings.Contains(prop, "{") {
			properties[i] = ":" + strings.Trim(prop, "{}")
		}
	}
	return strings.Join(properties, "/")
}
func ToUpperCamelCase(s string) string {
	if s == "" {
		return ""
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

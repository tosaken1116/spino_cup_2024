package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func main() {
	opts := &protogen.Options{}
	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if strings.Contains(*f.Proto.Name, "resource") {
				generateDomainModel(gen, f)
				continue
			}
			if strings.Contains(*f.Proto.Name, "rpc") {
				generateSchema(gen, f)
				continue
			}
			if !strings.Contains(*f.Proto.Name, "rpc") && !strings.Contains(*f.Proto.Name, "resource") {
				generateWSClient(gen, f)
			}
		}
		return nil
	})
}

func generateSchema(gen *protogen.Plugin, file *protogen.File) {
	packageName := strings.Replace(strings.ToLower(strings.Replace(string(*file.Proto.Package), "api.", "", -1)), ".rpc", "", -1)
	outputPath := filepath.Join(packageName, "schema.ts")
	if _, err := os.Stat(outputPath); err == nil {
		// ファイルが既に存在する場合、生成をスキップ
		return
	}
	g := gen.NewGeneratedFile(outputPath, "")

	// import 文を先に書き出すためのマップ
	imports := map[string]bool{}
	usedTypes := map[string]bool{}

	g.P("// Code generated by protoc-gen-ts. DO NOT EDIT.")
	g.P("// biome-ignore")
	g.P(fmt.Sprintf("// source: %s", file.Desc.Path()))

	// 各メッセージのフィールドを処理し、メッセージ型を使っている場合に import を追加
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Message != nil {
				// 他のメッセージ型の場合、import を追加
				importPath := generateImportPath(file, field.Message)
				imports[importPath] = true
				usedTypes[field.Message.GoIdent.GoName] = true
			}
		}
	}

	// import 文をファイルの先頭に書き出し
	for importPath := range imports {
		g.P(fmt.Sprintf("import { %s } from '%s';", getImportedTypes(usedTypes), importPath))
	}

	// スキーマの生成
	for _, message := range file.Messages {
		g.P(fmt.Sprintf("export type %s = {", message.GoIdent.GoName))
		for _, field := range message.Fields {
			if field.Message != nil {
				// メッセージ型のフィールドの場合、型名を出力
				tsType := field.Message.GoIdent.GoName
				arrayContext := func() string {
					if field.Desc.IsList() {
						return tsType + "[]"
					}
					return tsType
				}()

				g.P(fmt.Sprintf("  %s: %s;", field.Desc.Name(), arrayContext))
			} else {
				// プリミティブ型の場合
				tsType := goToTSType(field.Desc.Kind().String())
				arrayContext := func() string {
					if field.Desc.IsList() {
						return tsType + "[]"
					}
					return tsType
				}()

				g.P(fmt.Sprintf("  %s: %s;", field.Desc.Name(), arrayContext))
			}
		}
		g.P("};")
	}
}

// import パスの生成
func generateImportPath(file *protogen.File, message *protogen.Message) string {
	return fmt.Sprintf("./model")
}

// インポートする型名を抽出
func getImportedTypes(usedTypes map[string]bool) string {
	types := ""
	for t := range usedTypes {
		types += t + ", "
	}
	return strings.TrimRight(types, ", ")
}

// Goの型をTypeScriptの型に変換する関数
func goToTSType(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "int32", "int64", "uint32", "uint64":
		return "number"
	case "bool":
		return "boolean"
	case "float", "double":
		return "number"
	default:
		return "any"
	}
}
func generateDomainModel(gen *protogen.Plugin, file *protogen.File) {
	// "domain/[package]/model.ts" にファイルを生成
	packageName := strings.Replace(strings.ToLower(strings.Replace(string(*file.Proto.Package), "api.", "", -1)), ".resources", "", -1)
	outputPath := filepath.Join(packageName, "model.ts")
	if _, err := os.Stat(outputPath); err == nil {
		// ファイルが既に存在する場合、生成をスキップ
		return
	}
	g := gen.NewGeneratedFile(outputPath, "")

	// import 文を先に書き出すためのマップ
	imports := map[string]bool{}
	usedTypes := map[string]bool{}

	g.P("// Code generated by protoc-gen-ts. DO NOT EDIT.")
	g.P(fmt.Sprintf("// source: %s", file.Desc.Path()))

	// 各メッセージのフィールドを処理し、メッセージ型を使っている場合に import を追加
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Message != nil {
				// 他のメッセージ型の場合、import を追加
				importPath := generateImportPath(file, field.Message)
				imports[importPath] = true
				usedTypes[field.Message.GoIdent.GoName] = true
			}
		}
	}

	// import 文をファイルの先頭に書き出し
	for importPath := range imports {
		g.P(fmt.Sprintf("import { %s } from '%s';", getImportedTypes(usedTypes), importPath))
	}

	// 各メッセージの型定義を生成
	for _, message := range file.Messages {
		g.P(fmt.Sprintf("export type %s = {", message.GoIdent.GoName))
		for _, field := range message.Fields {
			if field.Message != nil {
				// メッセージ型のフィールドの場合、型名を出力
				tsType := field.Message.GoIdent.GoName
				arrayContext := func() string {
					if field.Desc.IsList() {
						return tsType + "[]"
					}
					return tsType
				}()

				g.P(fmt.Sprintf("  %s: %s;", field.Desc.Name(), arrayContext))
			} else {
				// プリミティブ型の場合
				tsType := goToTSType(field.Desc.Kind().String())
				arrayContext := func() string {
					if field.Desc.IsList() {
						return tsType + "[]"
					}
					return tsType
				}()

				g.P(fmt.Sprintf("  %s: %s;", field.Desc.Name(), arrayContext))
			}
		}
		g.P("}")
	}
}

func generateWSClient(gen *protogen.Plugin, file *protogen.File) {
	packageName := strings.Replace(strings.ToLower(string(*file.Proto.Package)), "api.", "", -1)
	// "apiclient/index.ts" にファイルを生成
	outputPath := filepath.Join(packageName, "index.ts")
	if _, err := os.Stat(outputPath); err == nil {
		// ファイルが既に存在する場合、生成をスキップ
		return
	}
	g := gen.NewGeneratedFile(outputPath, "")
	handleEventsContexts := make([]string, 0)
	// import 文を先に生成
	g.P("// Code generated by protoc-gen-ts. DO NOT EDIT.")
	g.P(fmt.Sprintf("import type * as %sSchema from './schema';", ToUpperCamelCase(packageName)))
	g.P("import ReconnectingWebSocket from \"reconnecting-websocket\";")
	g.P("import { useEffect, useRef } from \"react\";")

	g.P("type Props = {")
	g.P("	baseUrl: string;")
	for _, service := range file.Services {
		for _, method := range service.Methods {
			respType := fmt.Sprintf("%sSchema.%s[\"payload\"]", ToUpperCamelCase(packageName), method.Output.GoIdent.GoName)
			if method.Output.GoIdent.GoName == "Empty" {
				handleEventsContexts = append(handleEventsContexts, method.GoName)
				continue
			}
			g.P(fmt.Sprintf("	%s: (payload:%s)=>void;", method.Output.GoIdent.GoName, respType))
		}
	}
	g.P("}")
	g.P(fmt.Sprintf("export const use%sWSClient = (props:Props) => {", ToUpperCamelCase(packageName)))
	g.P("	const connectionRef = useRef<ReconnectingWebSocket | null>(")
	g.P("		null,")
	g.P("	);")
	g.P("	const handleEvents = (e:MessageEvent) =>{")
	g.P("		const data = JSON.parse(e.data);")
	g.P("		switch (data.type) {")
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Output.GoIdent.GoName == "Empty" {
				continue
			}
			// レスポンス型の生成
			respType := fmt.Sprintf("%sSchema.%s", ToUpperCamelCase(packageName), method.Output.GoIdent.GoName)
			// 各APIメソッドの生成
			g.P(fmt.Sprintf("				case '%s':", method.Desc.Name()))
			g.P(fmt.Sprintf("					props.%s(data.payload as %s[\"payload\"])", method.Desc.Name(), respType))
			g.P("					break;")
		}
	}
	g.P("			}")
	g.P("	}")

	for _, events := range handleEventsContexts {
		g.P(fmt.Sprintf("	const handle%s = (payload:%sSchema.%s[\"payload\"]) => {", events, ToUpperCamelCase(packageName), events))
		g.P(fmt.Sprintf("		connectionRef.current?.send(JSON.stringify({type:'%s', payload:payload}))", events))
		g.P("	}")
	}
	g.P("	useEffect(() => {")
	g.P("			const ws = new ReconnectingWebSocket(props.baseUrl);")
	g.P("			connectionRef.current = ws;")
	g.P("			ws.onmessage = handleEvents;")
	g.P("			return () => {")
	g.P("				ws.close();")
	g.P("			}")
	g.P("	})")
	g.P("	return {")
	for _, events := range handleEventsContexts {
		g.P(fmt.Sprintf("		handle%s,", events))
	}
	g.P("		connection: connectionRef.current")
	g.P("	}")
	g.P("}")

}

// HTTP ルールを取得するための関数
func getHttpRule(method *protogen.Method) *annotations.HttpRule {
	if proto.HasExtension(method.Desc.Options(), annotations.E_Http) {
		ext := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
		if httpRule, ok := ext.(*annotations.HttpRule); ok {
			return httpRule
		}
	}
	return nil
}

// HTTP メソッドを取得するための関数
func getHttpMethod(httpRule *annotations.HttpRule) string {
	if httpRule == nil {
		return "POST"
	}
	switch httpRule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return "GET"
	case *annotations.HttpRule_Post:
		return "POST"
	case *annotations.HttpRule_Put:
		return "PUT"
	case *annotations.HttpRule_Delete:
		return "DELETE"
	default:
		return "POST"
	}
}

// URL パスを取得するための関数
func getUrlPath(httpRule *annotations.HttpRule) string {
	if httpRule == nil {
		return "/defaultPath"
	}
	switch pattern := httpRule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return pattern.Get
	case *annotations.HttpRule_Post:
		return pattern.Post
	case *annotations.HttpRule_Put:
		return pattern.Put
	case *annotations.HttpRule_Delete:
		return pattern.Delete
	default:
		return "/defaultPath"
	}
}

func applyPathParamsToURL(path string) string {
	if !strings.Contains(path, "{") {
		return path
	}

	properties := strings.Split(path, "/")
	for i, prop := range properties {
		if strings.Contains(prop, "{") {
			properties[i] = "${req." + strings.Trim(prop, "{}") + "}"
		}
	}
	return strings.Join(properties, "/")
}
func ToUpperCamelCase(s string) string {
	if s == "" {
		return ""
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}
